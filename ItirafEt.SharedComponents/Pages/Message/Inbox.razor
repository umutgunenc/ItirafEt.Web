@page "/inbox"

@inject IMessageApi MessageApi
@inject AuthStateProvider AuthStateProvider
@inject NavigationManager NavigationManager
@inject InboxService InboxService
@inject SignalRInboxService SignalRInboxService
@inject IStorageService StorageService
@implements IAsyncDisposable


<div class="col-lg-8 col mx-auto py-5">

	@if (_isError)
	{
		<div class="alert alert-danger" role="alert">
			@_errorMessage
		</div>
	}
	else
	{
		<div class="list-group">

			@foreach (var inboxItem in _inboxItems)
			{
				var now = DateTime.Now;
				var diff = now - inboxItem.LastMessageDate;
				string timeText;

				if (diff.TotalMinutes < 1)
				{
					timeText = "şimdi";
				}
				else if (diff.TotalMinutes < 60)
				{
					timeText = $"{(int)diff.TotalMinutes} dk önce";
				}
				else if (diff.TotalHours < 24)
				{
					timeText = $"{(int)diff.TotalHours} saat önce";
				}
				else
				{
					timeText = inboxItem.LastMessageDate.ToString("dd MMMM yyyy");
				}

				<a @onclick="()=>NavigateToConversation(inboxItem.ConversationId)" class="list-group-item list-group-item-action d-flex gap-3 py-3" aria-current="true" style="cursor:pointer">
					<img src="@(string.IsNullOrEmpty(inboxItem.SenderUserProfileImageUrl) ? "/anonymousIcon.png" : inboxItem.SenderUserProfileImageUrl)" alt="" width="56" height="56" class="rounded-circle flex-shrink-0 profile-photo" @onclick:stopPropagation="true" style="cursor:auto">

					<div class="d-flex gap-2 w-100 justify-content-between">
						<div>
							<h6 class="mb-2">
								@inboxItem.SenderUserUserName
								@if (inboxItem.UnreadMessageCount > 0)
								{
									<span class="badge bg-danger ms-2">@inboxItem.UnreadMessageCount</span>
								}
							</h6>
							<p class="mb-0 opacity-75">
								@if (string.IsNullOrWhiteSpace(inboxItem.LastMessagePrewiew))
								{
									<span style="position: relative; top: -2px;">📷</span>
									<span>Fotoğraf</span>
								}
								else
								{
									@(inboxItem.LastMessagePrewiew.Length > 20
																? inboxItem.LastMessagePrewiew.Substring(0, 20) + "..."
																: inboxItem.LastMessagePrewiew)
								}
							</p>
						</div>
						<small class="opacity-50 text-nowrap">@timeText</small>
					</div>
				</a>
			}
		</div>
	}
</div>


@code {

	private Guid _currentUserId;
	private List<InboxViewModel>? _inboxItems = new();
	private bool _isError = false;
	private string? _errorMessage;
	private Func<InboxViewModel, Task>? _onNewMessageHandler;
	private Func<Guid, Guid, Task>? _onMessageReadHandler;
	// private bool _isInitialized = false;

	protected override async Task OnInitializedAsync()
	{
		// if (_isInitialized)
		// 	return;
		// _isInitialized = true;
		GetUserId();

		await SignalRInboxService.StartAsync(_currentUserId);
		await SignalRInboxService.StartReadMessageAsync(_currentUserId);
		await GetUserMessagesAsync();

		_onNewMessageHandler = async model =>
			await UpdateInboxItemUnreadMessageCountAsync(model);

		_onMessageReadHandler = async (userId, conversationId) =>
			await UpdateInboxItemAfterReadUnreadMessageAsync(userId, conversationId);

		SignalRInboxService.NewInboxMessage += _onNewMessageHandler;
		SignalRInboxService.MessageRead += _onMessageReadHandler;
		InboxService.OnUnreadMessageChanged += RefreshInbox;
		InboxService.InboxItemsOrderChanged += RefreshInbox;

		await InvokeAsync(StateHasChanged);
	}

	private async Task RefreshInbox()
	{
		_inboxItems = await InboxService.GetUserConversationsAsync();
		await InboxService.RemoveConversationsFromLocalStorageAsync();
		_inboxItems.Sort((a, b) => b.LastMessageDate.CompareTo(a.LastMessageDate));
		await InvokeAsync(StateHasChanged);
		await InboxService.SetUserConversationsToLocalStorageAsync(_inboxItems);

	}
	private void GetUserId()
	{
		if (Guid.TryParse(AuthStateProvider.User?.id, out Guid parsedId))
			_currentUserId = parsedId;
	}
	private async Task GetUserMessagesAsync()
	{
		await InboxService.InitializeAsync(_currentUserId);

		if (InboxService._haveError)
		{
			_isError = true;
			_errorMessage = InboxService._errorMessage;
		}
		else
		{
			_isError = false;
			_inboxItems = await InboxService.GetUserConversationsAsync();
			_inboxItems.Sort((a, b) => b.LastMessageDate.CompareTo(a.LastMessageDate));
			await InboxService.RemoveConversationsFromLocalStorageAsync();
			await InboxService.SetUserConversationsToLocalStorageAsync(_inboxItems);

		}
	}

	private async Task UpdateInboxItemUnreadMessageCountAsync(InboxViewModel model)
	{
		if (_inboxItems.Count == 0)
			_inboxItems = new();
		else
			_inboxItems = await InboxService.GetUserConversationsAsync();

		await InboxService.RemoveConversationsFromLocalStorageAsync();

		var existingIndex = _inboxItems.FindIndex(i => i.ConversationId == model.ConversationId);

		if (existingIndex != -1)
		{
			var existingItem = _inboxItems[existingIndex];
			model.UnreadMessageCount = existingItem.UnreadMessageCount + 1;

			_inboxItems.RemoveAt(existingIndex);
		}

		_inboxItems.Insert(0, model);

		await InboxService.SetUserConversationsToLocalStorageAsync(_inboxItems);
		await InvokeAsync(StateHasChanged);
	}

	private async Task UpdateInboxItemAfterReadUnreadMessageAsync(Guid currentUserId, Guid conversationId)
	{
		_inboxItems = await InboxService.GetUserConversationsAsync();
		await InboxService.RemoveConversationsFromLocalStorageAsync();
		if (_currentUserId == currentUserId)
		{
			var item = _inboxItems.FirstOrDefault(i => i.ConversationId == conversationId);
			if (item != null && item.UnreadMessageCount > 0)
			{
				item.UnreadMessageCount -= 1;
				await InvokeAsync(StateHasChanged);
			}
		}
		await InboxService.SetUserConversationsToLocalStorageAsync(_inboxItems);
	}
	private void NavigateToConversation(Guid conversationId)
	{
		NavigationManager.NavigateTo($"/conversations/{conversationId}");
	}

	public ValueTask DisposeAsync()
	{
		InboxService.OnUnreadMessageChanged -= RefreshInbox;
		InboxService.InboxItemsOrderChanged -= RefreshInbox;
		SignalRInboxService.NewInboxMessage -= _onNewMessageHandler;
		SignalRInboxService.MessageRead -= _onMessageReadHandler;
		return ValueTask.CompletedTask;
	}
}