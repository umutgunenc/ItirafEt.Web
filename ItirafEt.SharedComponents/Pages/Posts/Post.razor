@page "/posts/{postId:int}"
@using ItirafEt.Shared.Models
@inject IPostApi PostApi
@inject IReactionApi ReactionApi
@inject ICommentApi CommentApi
@inject IPostViewApi PostViewApi
@inject IMessageApi MessageApi
@inject AuthStateProvider AuthStateProvider
@inject NavigationManager NavigationManager
@inject ISignalRService SignalRService
@inject IDateTimeHelperService DateTimeHelperService



<div class="col-lg-8 col mx-auto py-lg-5 px-lg-2">
	<div class="card shadow-lg rounded-0 border-1 mb-lg-3 text-bg-light">
		@if (_isPostHaveError)
		{
			<div class="alert alert-danger m-3" role="alert">
				@_errorMessage
			</div>
		}
		else
		{
			@if (_isBusy)
			{
				<div class="d-flex justify-content-center align-items-center" style="height: 20vh;">
					<div class="spinner-border text-primary fs-5" role="status" style="width: 3rem; height: 3rem;">
						<span class="visually-hidden">Loading...</span>
					</div>
				</div>
			}
			else
			{

				<div class="card-body">
					<h5 class="card-title fw-bold text-break">@_postDto.Title</h5>

					<p class="card-text text-break"
					   style="text-align: justify;
					text-justify: inter-word;
					white-space: pre-wrap;">
						@_postDto.Content
					</p>

					<div class="d-flex flex-column flex-lg-row justify-content-between">

						<!-- Web (lg-) -->
						<div class="d-none d-lg-flex gap-2 align-items-start">
							<div class="d-flex align-items-center  gap-2 ">
								<button class="@($"btn-like{(_isAlreadyLiked ? " liked" :"")}")" style="height:30px; width:30px" @onclick="LikePostAsync">
									<i class="@($"bi bi-heart{(_isAlreadyLiked ? "-fill":"")}")" style="height:20px;"></i>
								</button>
								<span class="text-muted small" style="cursor:pointer" @onclick="ShowLikes">
									@_likeCount
								</span>
							</div>
							<div class="d-flex align-items-center  gap-2 ">
								<button class="@($"btn-dislike{(_isAlreadyDisliked ? " disliked" :"")}")" style="height:30px; width:30px" @onclick="DislikePostAsync">
									<i class="@($"bi bi-heartbreak{(_isAlreadyDisliked ? "-fill":"")}")" style="height:20px;"></i>
								</button>
								<span class="text-muted small" style="cursor:pointer" @onclick="ShowDislikes">
									@_dislikeCount
								</span>
							</div>
							@if (!_isPostOwner)
							{
								<div class="d-flex align-items-center" @onclick="ReportPost">
									<button class="btn-report" style="height:30px; width:30px">
										<i class="bi bi-exclamation-circle" style="height:25px;"></i>
									</button>
								</div>
							}
						</div>

						<!-- Right Section (Always) -->
						<div class="order-lg-2 mb-2 mb-lg-0 text-end">
							<!-- Tarih -->
							<div class="text-muted small">
								@_postDto.CreatedDate.ToString("dd/MM/yyyy HH:mm")
								@if (_postDto.UpdatedDate.HasValue)
								{
									@($" - {_postDto.UpdatedDate.Value.ToString("dd/MM/yyyy HH:mm")}")
								}
							</div>
							<!-- Görüntülenme -->
							<div class="text-muted small mt-2" style="cursor:pointer" @onclick="ShowViwers">
								<i class="bi bi-eye me-1"></i>@_postViewCount
							</div>
						</div>

						<!-- Mobile (lg-) -->
						<div class="d-flex d-lg-none justify-content-end gap-2 mt-2 order-3">
							<!-- Beğeni -->
							<div class="d-flex align-items-center gap-2 ">
								<button class="btn-like" style="height:30px; width:30px" @onclick="LikePostAsync">
									<i class="@($"bi bi-heart{(_isAlreadyLiked ? "-fill":"")}")" style="height:20px;"></i>
								</button>
								<span class="text-muted small" style="cursor:pointer" @onclick="ShowLikes">
									@_likeCount
								</span>
							</div>
							<div class="d-flex align-items-center  gap-2 ">
								<button class="btn-dislike" style="height:30px; width:30px" @onclick="DislikePostAsync">
									<i class="@($"bi bi-heartbreak{(_isAlreadyDisliked ? "-fill":"")}")" style="height:20px;"></i>
								</button>
								<span class="text-muted small" style="cursor:pointer" @onclick="ShowDislikes">
									@_dislikeCount
								</span>
							</div>
							@if (!_isPostOwner)
							{
								<div class="d-flex align-items-center" @onclick="ReportPost">
									<button class="btn-report" style="height:30px; width:30px">
										<i class="bi bi-exclamation-circle" style="height:25px;"></i>
									</button>
								</div>
							}
						</div>
					</div>

					<hr />

					<div class="d-flex flex-column gap-2 mb-4">
						<!-- Üst Bilgi Satırı -->
						<div class="d-flex align-items-center gap-3">
							<!-- Profil Fotoğrafı -->
							<img src="@(string.IsNullOrEmpty(_postDto.UserProfileImageUrl)? "/anonymousIcon.png" : _postDto.UserProfileImageUrl)"
								 class="profile-photo rounded-circle"
								 width="56" height="56">

							<!-- Kullanıcı Bilgileri -->
							<div class="d-flex flex-column">
								<div class="d-flex align-items-center gap-2 mb-2">
									<h5 class="mb-0" style="font-weight: 700; color: #2d3436; cursor:pointer" @onclick="ShowUserProfile">@_postDto.UserName</h5>
								</div>

								<div class="d-flex  align-items-center justify-content-between">

									<div class="d-flex align-items-center gap-2">
										<span style="background: #f2f2f2; color: #636e72; border: 1px solid #dee2e6; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
											@_postDto.UserAge
										</span>
										@if (_postDto.UserGenderId == (int)GenderEnum.Male)
										{
											<span style="background: rgba(9, 132, 227, 0.1); color: #0984e3; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												<i class="bi bi-gender-male me-1"></i>Erkek
											</span>
										}
										else if (_postDto.UserGenderId == (int)GenderEnum.Female)
										{
											<span style="background: rgba(232, 67, 147, 0.1); color: #e84393; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												<i class="bi bi-gender-female me-1"></i>Kadın
											</span>
										}
										@if (_currentUserId != _postDto.UserId)
										{
											<a style="text-decoration: none; color:lightseagreen; cursor:pointer" @onclick="()=>SendMessageAsync(_postDto.UserId)">
												<i class="bi bi-chat-right-heart-fill" style="font-size: 1.25rem;"></i>
											</a>
										}
									</div>
								</div>
							</div>
						</div>
					</div>

					<div class="mt-4">
						<h6 class="fw-bold" @onclick="ShowComments" style="cursor:pointer">
							Yorumlar @($"({_comments?.Count ?? 0})") 														<i class="bi @(_showComments ? "bi-caret-up-fill" : "bi-caret-down-fill")"></i>

						</h6>
					</div>
					@if (_showComments)
					{
						<div class="my-4">
							@if (_comments?.Count > 0)
							{
								<EditForm Model="_commentModel" OnValidSubmit="AddCommentAsync">
									<DataAnnotationsValidator />

									<div class="mb-3">
										<InputTextArea id="yorum"
													   class="form-control"
													   placeholder="Yorum yazın..."
													   @bind-Value="_commentModel.Content"
													   rows="4" />
										<ValidationMessage For="@(() => _commentModel.Content)" />
									</div>

									<div class="my-3">
										<button type="submit" class="btn-custom col-12" disabled="@_isApiBusy">Gönder</button>
									</div>
								</EditForm>

								<div class="card mb-2 shadow-sm">
									<div class="card-body p-2">
										<!-- Yorum listesi -->
										@foreach (var comment in _comments)
										{
											<div>
												<img src="@(string.IsNullOrEmpty(comment.CommentUserProfilPhotoUrl)? "/anonymousIcon.png" : comment.CommentUserProfilPhotoUrl)"
													 class="profile-photo rounded-circle"
													 width="40" height="40" />
												<strong class="ms-2" @onclick="()=>NavigateToUserProfile(comment.UserId)" style="cursor:pointer">@comment.UserName</strong>

											</div>
											<small class="text-muted" style="font-size:12px;">@comment.CreatedDate.ToString("dd/MM/yyyy HH:mm") @(comment.UpdatedDate != null ? $"- {comment.UpdatedDate.Value.ToString("dd/MM/yyyy HH:mm")}" : "")</small>

											@if (!comment.IsCommentEditing)
											{
												<p class="m-0 my-2 @(!comment.IsActive ? "text-decoration-line-through" : "")" style="white-space: pre-wrap;">@comment.Content</p>
											}
											else
											{
												<EditForm Model="comment" OnValidSubmit="async ()=> await EditCommentAsync(comment.Id)">
													<DataAnnotationsValidator />

													<div class="my-3">
														<InputTextArea class="form-control"
																	   placeholder="Yorumunuzu düzenleyin..."
																	   @bind-Value="comment.Content"
																	   rows="4" />
														<ValidationMessage For="@(() => comment.Content)" />
													</div>

													<div class="d-flex justify-content-start my-3 gap-2">
														<button type="submit" class="btn-custom" disabled="@_isApiBusy">Değiştir</button>
														<button type="button" class="btn-custom-red" @onclick="async ()=> await DisplayCommentEditingAsync(comment.Id)" disabled="@_isApiBusy">İptal</button>
													</div>
												</EditForm>
											}
											<div class="d-flex justify-content-start m-0 my-1 gap-2">

												@if (comment.IsActive)
												{
													<div class="d-flex gap-2 align-items-start">
														<div class="d-flex align-items-center  gap-2 ">
															@if (comment.CommentRections?.Any(cr => cr.ReactingUserId == _currentUserId && cr.ReactionTypeId == (int)ReactionTypeEnum.Like) == true)
															{
																<button class="btn-like liked" style="height:30px; width:30px" @onclick="async () => await LikeCommentAsync(comment.Id)">
																	<i class="bi bi-heart-fill" style="height:20px;"></i>
																</button>
															}
															else
															{
																<button class="btn-like" style="height:30px; width:30px" @onclick="async () => await LikeCommentAsync(comment.Id)">
																	<i class="bi bi-heart" style="height:20px;"></i>
																</button>
															}

															<span class="text-muted small" style="cursor:pointer">@comment.LikeCount</span>
														</div>

														<div class="d-flex align-items-center  gap-2 ">

															@if (comment.CommentRections?.Any(cr => cr.ReactingUserId == _currentUserId && cr.ReactionTypeId == (int)ReactionTypeEnum.Dislike) == true)
															{

																<button class="btn-dislike disliked" style="height:30px; width:30px" @onclick="async () => await DislikeCommentAsync(comment.Id)">
																	<i class="bi bi-heartbreak-fill" style="height:20px;"></i>
																</button>
															}
															else
															{

																<button class="btn-dislike" style="height:30px; width:30px" @onclick="async () => await DislikeCommentAsync(comment.Id)">
																	<i class="bi bi-heartbreak" style="height:20px;"></i>
																</button>
															}
															<span class="text-muted small" style="cursor:pointer">@comment.DislikeCount</span>
														</div>

														@if (comment.UserId != _currentUserId)
														{
															<div class="d-flex align-items-center">
																<button class="btn-report" style="height:30px; width:30px">
																	<i class="bi bi-exclamation-circle"></i>
																</button>
															</div>
														}
													</div>
												}


												@if (comment.IsActive && (comment.UserId == _currentUserId || adminRoles.Contains(_userRoleId)))
												{
													@if (comment.UserId == _currentUserId)
													{
														<div>
															<button class="btn-custom-orange-circle" @onclick="async ()=> await DisplayCommentEditingAsync(comment.Id)" style="height:30px; width:30px">
																<i class="bi bi-pen"></i>
															</button>
														</div>
													}

													<div>
														<button class="btn-custom-red-circle" @onclick="async ()=> await DisplayCommentDeleteWarningAsync(comment.Id)" style="height:30px; width:30px">
															<i class="bi bi-trash-fill"></i>
														</button>
													</div>
												}
												@if (comment.IsActive)
												{
													<button class="btn-custom-circle" @onclick="() => ToggleReplyBox(comment.Id)" style="height:30px; width:30px">
														<i class="bi bi-chat-right-quote" style="height:20px;"></i>
													</button>
												}

											</div>
											@if (comment.ShowDeleteWarning)
											{
												<div role="alert">
													<div>
														Yorumunuzu silmek istediğinize emin misiniz?
													</div>
													<div class="d-flex justify-content-start my-1 gap-2">
														<button class="btn-custom" @onclick="async ()=> await DisplayCommentDeleteWarningAsync(comment.Id)">Hayır</button>
														<button class="btn-custom-red" @onclick="async ()=> await DeleteCommentAsync(comment.Id)">Evet</button>
													</div>
												</div>

											}
											<!-- Reply input -->
											@if (_replyToCommentId == comment.Id)
											{
												<EditForm Model="_replyModel"
														  OnValidSubmit="()=>AddReplyAsync(comment.Id)">
													<DataAnnotationsValidator />
													<div class="input-group mb-2">
														<input type="text"
															   class="form-control form-control-sm"
															   placeholder="Cevabınızı yazın..."
															   @bind="_replyModel.Content" />
														<div class="input-group-append">
															<button class="btn-custom rounded-start-0" type="submit">
																Gönder
															</button>
														</div>
													</div>
													<ValidationMessage For="@(() => _replyModel.Content)" />
												</EditForm>
											}
											<!-- Alt yorumlar (replies) -->
											<div class="mt-2 d-flex align-items-end justify-content-between">
												@if (comment.CommentReplies?.Any() == true)
												{
													<h6 class="fw-semibold"
														@onclick="() => ShowCommentReplies(comment)"
														style="cursor:pointer">
														Cevaplar (@comment.CommentReplies.Count)
														<i class="bi @(comment.ShowReplies ? "bi-caret-up-fill" : "bi-caret-down-fill")"></i>
													</h6>
												}
												else
												{
													<h6 class="fw-semibold">
														Cevaplar (0)
													</h6>
												}

											</div>
											@if (comment.CommentReplies?.Any() == true && comment.ShowReplies)
											{
												<div class="ms-5">
													@foreach (var reply in comment.CommentReplies)
													{
														<div class="mb-1 bg-light border-1">
															<div class="card-text py-2 ps-2">
																<div class="d-flex justify-content-between">
																	<div>
																		<img src="@(string.IsNullOrEmpty(reply.CommentUserProfilPhotoUrl)? "/anonymousIcon.png" : reply.CommentUserProfilPhotoUrl)"
																			 class="profile-photo rounded-circle" width="40" height="40" />
																		<strong class="ms-2" @onclick="()=>NavigateToUserProfile(reply.UserId)" style="cursor:pointer">@reply.UserName</strong>
																	</div>
																</div>
																<small class="text-muted" style="font-size:12px;">@reply.CreatedDate.ToString("dd/MM/yyyy HH:mm") @(reply.UpdatedDate != null ? $"- {reply.UpdatedDate.Value.ToString("dd/MM/yyyy HH:mm")}" : "") </small>
																@if (!reply.IsCommentEditing)
																{
																	<p class="m-0 mt-2  @(!reply.IsActive ? "text-decoration-line-through" : "")" style="white-space: pre-wrap;">@reply.Content</p>
																}
																else
																{
																	<EditForm Model="reply" OnValidSubmit="async ()=> await EditCommentAsync(reply.Id)">
																		<DataAnnotationsValidator />

																		<div class="my-3">
																			<InputTextArea class="form-control"
																						   placeholder="Yorumunuzu düzenleyin..."
																						   @bind-Value="reply.Content"
																						   rows="4" />
																			<ValidationMessage For="@(() => reply.Content)" />
																		</div>

																		<div class="d-flex justify-content-start my-3 gap-2">
																			<button type="submit" class="btn-custom" disabled="@_isApiBusy">Değiştir</button>
																			<button type="button" class="btn-custom-red" @onclick="async ()=> await DisplayReplyEditingAsync(comment.Id,reply.Id)" disabled="@_isApiBusy">İptal</button>
																		</div>
																	</EditForm>
																}
																@if (reply.IsActive)
																{
																	<div class="d-flex justify-content-start gap-2">

																		<div class="d-flex align-items-center  gap-2 ">
																			@if (reply.CommentRections?.Any(cr => cr.ReactingUserId == _currentUserId && cr.ReactionTypeId == (int)ReactionTypeEnum.Like) == true)
																			{
																				<button class="btn-like liked" style="height:30px; width:30px" @onclick="async () => await LikeCommentAsync(reply.Id)">
																					<i class="bi bi-heart-fill" style="height:20px;"></i>
																				</button>
																			}
																			else
																			{
																				<button class="btn-like" style="height:30px; width:30px" @onclick="async () => await LikeCommentAsync(reply.Id)">
																					<i class="bi bi-heart" style="height:20px;"></i>
																				</button>
																			}
																			<span class="text-muted small" style="cursor:pointer">@reply.LikeCount</span>
																		</div>

																		<div class="d-flex align-items-center  gap-2 ">
																			@if (reply.CommentRections?.Any(cr => cr.ReactingUserId == _currentUserId && cr.ReactionTypeId == (int)ReactionTypeEnum.Dislike) == true)
																			{
																				<button class="btn-dislike disliked" style="height:30px; width:30px" @onclick="async () => await DislikeCommentAsync(reply.Id)">
																					<i class="bi bi-heartbreak-fill" style="height:20px;"></i>
																				</button>
																			}
																			else
																			{
																				<button class="btn-dislike" style="height:30px; width:30px" @onclick="async () => await DislikeCommentAsync(reply.Id)">
																					<i class="bi bi-heartbreak" style="height:20px;"></i>
																				</button>
																			}
																			<span class="text-muted small" style="cursor:pointer">@reply.DislikeCount</span>
																		</div>

																		@if (comment.UserId != _currentUserId)
																		{
																			<div class="d-flex align-items-center">
																				<button class="btn-report" style="height:30px; width:30px">
																					<i class="bi bi-exclamation-circle"></i>
																				</button>
																			</div>
																		}
																		@if (reply.UserId == _currentUserId && comment.IsActive || adminRoles.Contains(_userRoleId))
																		{
																			<div>
																				<button class="btn-custom-orange-circle" style="height:30px; width:30px" @onclick="async ()=> await DisplayReplyEditingAsync(comment.Id,reply.Id)">
																					<i class="bi bi-pen"></i>
																				</button>
																			</div>

																			<div>
																				<button class="btn-custom-red-circle" style="height:30px; width:30px" @onclick="async ()=> await DisplayReplyDeleteWarningAsync(comment.Id,reply.Id)">
																					<i class="bi bi-trash-fill"></i>
																				</button>
																			</div>
																		}



																	</div>
																}

																@if (reply.ShowDeleteWarning)
																{
																	<div class="" role="alert">
																		<div>
																			Yorumunuzu silmek istediğinize emin misiniz?
																		</div>
																		<div class="d-flex justify-content-start my-1 gap-2">
																			<button class="btn-custom" @onclick="async ()=> await DisplayReplyDeleteWarningAsync(comment.Id,reply.Id)">Hayır</button>
																			<button class="btn-custom-red" @onclick="async ()=> await DeleteCommentAsync(reply.Id)">Evet</button>
																		</div>
																	</div>
																}
															</div>
														</div>
													}
												</div>
											}
											<hr />
										}
									</div>
								</div>
							}
							@if (_comments?.Count == null)
							{
								<div class="alert alert-info" role="alert">
									@_commentErrorMessage
								</div>

								<EditForm Model="_commentModel"
										  OnValidSubmit="AddCommentAsync">
									<DataAnnotationsValidator />

									<div class="mb-3">
										<InputTextArea id="yorum"
													   class="form-control"
													   placeholder="Yorum yazın..."
													   @bind-Value="_commentModel.Content"
													   rows="4" />
										<ValidationMessage For="@(() => _commentModel.Content)" />
									</div>

									<div class="my-3">
										<button type="submit" class="blue col-12 text-white fw-medium" disabled="@_isApiBusy">Gönder</button>
									</div>
								</EditForm>
							}
							else if (_isCommentsHaveError)
							{
								<div class="alert alert-danger" role="alert">
									@_commentErrorMessage
								</div>
							}
						</div>
					}
				</div>
			}
		}
	</div>
</div>

<ModalComponent @ref="_likesModel" Title="Beğeneler" TitleClass="mx-auto" ChildClass="mb-3">
	<ChildContent>
		@if (_postReactions.Any(r => r.ReactionTypeId == (int)ReactionTypeEnum.Like))
		{
			@foreach (var reaction in _postReactions.OrderByDescending(x => x.CreatedDate))
			{
				@if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Like)
				{
					<div class="card mb-4 shadow border-0" style="border-radius: 1rem;">
						<div class="d-flex flex-column gap-2 my-3 mx-2">
							<!-- Üst Bilgi Satırı -->
							<div class="d-flex align-items-center gap-2 gap-md-4">
								<!-- Profil Fotoğrafı -->
								<img src="@(string.IsNullOrEmpty(reaction.ReactingUserProfileImageUrl)? "/anonymousIcon.png" : reaction.ReactingUserProfileImageUrl)"
									 class="profile-photo rounded-circle"
									 width="56" height="56">
								<div class="d-flex flex-column">
									<div class="d-flex align-items-center gap-1 gap-sm-3 mb-2">
										<h5 class="mb-0" style="font-weight: 700; color: #2d3436; cursor:pointer" @onclick="()=>ShowUserProfile(reaction.ReactingUserId)">@reaction.ReactingUserUserName</h5>
										<small>
											@reaction.CreatedDate.ToString("HH:mm dd/MM/yyyy")
										</small>
									</div>

									<div class="d-flex align-items-center justify-content-between">

										<div class="d-flex align-items-center gap-2">
											<span style="background: #f2f2f2; color: #636e72; border: 1px solid #dee2e6; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												@reaction.ReactingUserAge
											</span>
											@if (reaction.ReactingUserGenderId == (int)GenderEnum.Male)
											{
												<span style="background: rgba(9, 132, 227, 0.1); color: #0984e3; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
													<i class="bi bi-gender-male me-1"></i>Erkek
												</span>
											}
											else if (reaction.ReactingUserGenderId == (int)GenderEnum.Female)
											{
												<span style="background: rgba(232, 67, 147, 0.1); color: #e84393; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
													<i class="bi bi-gender-female me-1"></i>Kadın
												</span>
											}
											@if (_currentUserId != reaction.ReactingUserId)
											{
												<a style="text-decoration: none; color:lightseagreen; cursor:pointer" @onclick="()=>SendMessageAsync(reaction.ReactingUserId)">
													<i class="bi bi-chat-right-heart-fill" style="font-size: 1.25rem;"></i>
												</a>
											}

										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				}
			}
		}
		else
		{
			<div class="alert alert-info" role="alert">
				Gönderiyi henüz kimse beğenmedi.
			</div>
		}
	</ChildContent>
	<FooterContent>
		<button class="btn blue col text-white fw-medium" @onclick="_likesModel.Close">Kapat</button>
	</FooterContent>
</ModalComponent>

<ModalComponent @ref="_dislikeModel" Title="Beğenmeyenler" TitleClass="mx-auto" ChildClass="mb-3">
	<ChildContent>
		@if (_postReactions.Any(r => r.ReactionTypeId == (int)ReactionTypeEnum.Dislike))
		{
			@foreach (var reaction in _postReactions.OrderByDescending(x => x.CreatedDate))
			{
				@if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Dislike)
				{
					<div class="card mb-4 shadow border-0" style="border-radius: 1rem;">
						<div class="d-flex flex-column gap-2 my-3 mx-2">
							<!-- Üst Bilgi Satırı -->
							<div class="d-flex align-items-center gap-2 gap-sm-4">
								<!-- Profil Fotoğrafı -->
								<img src="@(string.IsNullOrEmpty(reaction.ReactingUserProfileImageUrl)? "/anonymousIcon.png" : reaction.ReactingUserProfileImageUrl)"
									 class="profile-photo rounded-circle"
									 width="56" height="56">
								<div class="d-flex flex-column">
									<div class="d-flex align-items-center gap-1 gap-sm-3 mb-2">
										<h5 class="mb-0" style="font-weight: 700; color: #2d3436; cursor:pointer" @onclick="()=>ShowUserProfile(reaction.ReactingUserId)">@reaction.ReactingUserUserName</h5>
										<small>
											@reaction.CreatedDate.ToString("HH:mm dd/MM/yyyy")
										</small>
									</div>

									<div class="d-flex align-items-center justify-content-between">

										<div class="d-flex align-items-center gap-2">
											<span style="background: #f2f2f2; color: #636e72; border: 1px solid #dee2e6; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												@reaction.ReactingUserAge
											</span>
											@if (reaction.ReactingUserGenderId == (int)GenderEnum.Male)
											{
												<span style="background: rgba(9, 132, 227, 0.1); color: #0984e3; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
													<i class="bi bi-gender-male me-1"></i>Erkek
												</span>
											}
											else if (reaction.ReactingUserGenderId == (int)GenderEnum.Female)
											{
												<span style="background: rgba(232, 67, 147, 0.1); color: #e84393; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
													<i class="bi bi-gender-female me-1"></i>Kadın
												</span>
											}
											@if (_currentUserId != reaction.ReactingUserId)
											{
												<a style="text-decoration: none; color:lightseagreen; cursor:pointer" @onclick="()=>SendMessageAsync(reaction.ReactingUserId)">
													<i class="bi bi-chat-right-heart-fill" style="font-size: 1.25rem;"></i>
												</a>
											}
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				}
			}
		}
		else
		{
			<div class="alert alert-info" role="alert">
				Gönderiyi beğenmeyen yok.
			</div>
		}
	</ChildContent>
	<FooterContent>
		<button class="btn blue col text-white fw-medium" @onclick="_dislikeModel.Close">Kapat</button>
	</FooterContent>
</ModalComponent>

<ModalComponent @ref="_viewerModel" Title="Okuyanlar" TitleClass="mx-auto" ChildClass="mb-3">
	<ChildContent>

		@if (_viewers.Count == 0)
		{
			<div class="alert alert-info" role="alert">
				Gönderiyi henüz kimse okumadı.
			</div>
		}
		else
		{
			@foreach (var viewer in _viewers.OrderByDescending(x => x.ReadDate))
			{
				<div class="card mb-4 shadow border-0" style="border-radius: 1rem;">
					<div class="d-flex flex-column gap-2 my-3 mx-2">
						<!-- Üst Bilgi Satırı -->
						<div class="d-flex align-items-center gap-2 gap-sm-4">
							<!-- Profil Fotoğrafı -->
							<img src="@(string.IsNullOrEmpty(viewer.PostViewerUserProfileImageUrl)? "/anonymousIcon.png" : viewer.PostViewerUserProfileImageUrl)"
								 class="profile-photo rounded-circle"
								 width="56" height="56"
								 style="object-fit: cover; border: 2px solid #ffffff; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
							<div class="d-flex flex-column">
								<div class="d-flex align-items-center gap-1 gap-md-3 mb-2">
									<h5 class="mb-0" style="font-weight: 700; color: #2d3436; cursor:pointer" @onclick="()=>ShowUserProfile(viewer.PostViewerUserId)">@viewer.PostViewerUserName</h5>
									<small>
										@viewer.ReadDate.ToString("HH:mm dd/MM/yyyy")
									</small>
								</div>

								<div class="d-flex align-items-center justify-content-between">

									<div class="d-flex align-items-center gap-2">
										<span style="background: #f2f2f2; color: #636e72; border: 1px solid #dee2e6; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
											@viewer.PostViewerAge
										</span>
										@if (viewer.PostViewerGenderId == (int)GenderEnum.Male)
										{
											<span style="background: rgba(9, 132, 227, 0.1); color: #0984e3; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												<i class="bi bi-gender-male me-1"></i>Erkek
											</span>
										}
										else if (viewer.PostViewerGenderId == (int)GenderEnum.Female)
										{
											<span style="background: rgba(232, 67, 147, 0.1); color: #e84393; border-radius: 20px; padding: 4px 12px; font-size: 0.8rem;">
												<i class="bi bi-gender-female me-1"></i>Kadın
											</span>
										}
										@if (_currentUserId != viewer.PostViewerUserId)
										{
											<a style="text-decoration: none; color:lightseagreen; cursor:pointer" @onclick="()=>SendMessageAsync(viewer.PostViewerUserId)">
												<i class="bi bi-chat-right-heart-fill" style="font-size: 1.25rem;"></i>
											</a>
										}
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			}
		}
	</ChildContent>
	<FooterContent>
		<button class="btn blue col text-white fw-medium" @onclick="_viewerModel.Close">Kapat</button>
	</FooterContent>
</ModalComponent>

<ModalComponent @ref="_sendMessageErrorModel" Title="Hata" TitleClass="mx-auto" ChildClass="mb-3">
	<ChildContent>

		<div class="alert alert-danger" role="alert">
			@_sendMessageError
		</div>

	</ChildContent>
	<FooterContent>
		<button class="btn blue col text-white fw-medium" @onclick="_sendMessageErrorModel.Close">Kapat</button>
	</FooterContent>
</ModalComponent>

@code {

	[Parameter]
	public int postId { get; set; }


	private PostViewModel? _postDto = new();
	private CommentsViewModel _commentModel = new();
	private CommentsViewModel _replyModel = new();
	private List<CommentsViewModel>? _comments = new();
	private List<ReactionViewModel> _postReactions = new();
	private List<PostViewersViewModel>? _viewers = new();
	private ConversationViewModel? _conversationDto = new();
	private HubConnection? _reactionHubConnection;
	private HubConnection? _commentHubConnection;
	private HubConnection? _postViewHubConnection;
	private ModalComponent? _likesModel;
	private ModalComponent? _dislikeModel;
	private ModalComponent? _viewerModel;
	private ModalComponent? _sendMessageErrorModel;
	private Guid? _currentUserId;
	private List<string> allowedRoles = new List<string>
	{
		nameof(UserRoleEnum.SuperAdmin),
		nameof(UserRoleEnum.Admin),
		nameof(UserRoleEnum.Moderator),
		nameof(UserRoleEnum.SuperUser)
	};

	private List<string> adminRoles = new List<string> {
		nameof(UserRoleEnum.SuperAdmin),
		nameof(UserRoleEnum.Admin),
		nameof(UserRoleEnum.Moderator)
	};
	private int? _likeCount;
	private int? _dislikeCount;
	private int? _postViewCount;
	private int? _replyToCommentId;
	private bool _isApiBusy = false;
	private bool _isBusy = true;
	private bool _isPostOwner = false;
	private bool _isUserLoggedIn = false;
	private bool _isAlreadyLiked = false;
	private bool _isAlreadyDisliked = false;
	private bool _showComments = false;
	private bool _isCommentsHaveError = false;
	private bool _isPostHaveError = false;
	private bool _showCommentReplies = false;
	private string? _newCommentText;
	private string? _errorMessage;
	private string? _commentErrorMessage;
	private string? _replyText;
	private string? _userRoleId = null;
	private string? _sendMessageError;
	private string _userTimeZoneId = string.Empty;
	private string _commentContent = string.Empty;

	protected override async Task OnParametersSetAsync()
	{
		ResetPage();
		CheckUserLoggedIn();
		GetUserRoleId();

		try
		{
			_userTimeZoneId = await DateTimeHelperService.GetUserTimeZoneIdAsync();
		}
		catch (Exception)
		{
			_userTimeZoneId = "UTC";
		}
		await StartTasksWithUserRoleAsync();
		UserPostOwner();

		await StartReactionHubConnectionAsync();
		await StartPostViewHubConnectionAsync();
		await StartCommentHubConnectionAsync();

		if (allowedRoles.Contains(_userRoleId))
		{
			UpdatePostReactionCounts();
			UpdatePostReactionButtons();
		}

		await ReadPostAsync();

		_isBusy = false;

	}
	private void ResetPage()
	{
		_isPostHaveError = false;
		_isApiBusy = false;
		_isBusy = true;
		_showComments = false;
		_isCommentsHaveError = false;
		_commentErrorMessage = null;

	}
	private async Task StartReactionHubConnectionAsync()
	{

		_reactionHubConnection = SignalRService.ConfigureHubConnection(HubConstants.HubType.Reaction);


		if (!allowedRoles.Contains(_userRoleId))
		{
			_reactionHubConnection.On<int?, int>("PostLikedOrDislikedAnonymousAsync", async (oldReactionId, newReactionId) =>
			{
				UpdatePostReactions(oldReactionId, newReactionId);
				await InvokeAsync(StateHasChanged);
			});

			_reactionHubConnection.On<int, int?, int>("CommentLikedOrDislikedAnonymousAsync", async (commentId, oldReactionId, newReactionId) =>
			{
				UpdateCommentReactions(commentId, oldReactionId, newReactionId);
				await InvokeAsync(StateHasChanged);
			});
		}
		else
		{
			_reactionHubConnection.On<ReactionViewModel, bool>("PostLikedOrDislikedAsync", async (reaction, isReactionUpdated) =>
			{
				UpdatePostReactions(reaction, isReactionUpdated);
				await InvokeAsync(StateHasChanged);
			});

			_reactionHubConnection.On<ReactionViewModel, bool>("CommentLikedOrDislikedAsync", async (reaction, isReactionUpdated) =>
			{
				UpdateCommentReactions(reaction, isReactionUpdated);
				await InvokeAsync(StateHasChanged);
			});
		}

		await _reactionHubConnection.StartAsync();
		await _reactionHubConnection.SendAsync("JoinPostReactionGroup", postId);

	}
	private async Task StartPostViewHubConnectionAsync()
	{

		_postViewHubConnection = SignalRService.ConfigureHubConnection(HubConstants.HubType.PostView);

		if (allowedRoles.Contains(_userRoleId))
		{
			_postViewHubConnection.On<int, PostViewersViewModel>("PostViewedAsync", async (postId, postViewerDto) =>
			{
				if (_viewers == null)
					_viewers = new List<PostViewersViewModel>();

				_viewers.Add(postViewerDto);
				_postViewCount = _viewers.Count;

				await InvokeAsync(StateHasChanged);

			});
		}
		else
		{
			_postViewHubConnection.On<int>("PostViewedAnonymousAsync", async (postId) =>
			{
				_postViewCount++;
				await InvokeAsync(StateHasChanged);
			});
		}

		await _postViewHubConnection.StartAsync();
		await _postViewHubConnection.SendAsync("JoinPostPostViewCountGroup", postId);

	}
	private async Task StartCommentHubConnectionAsync()
	{
		_commentHubConnection = SignalRService.ConfigureHubConnection(HubConstants.HubType.Comment);

		_commentHubConnection.On<CommentsViewModel, bool>("CommentAddedOrEditedAsync", async (commentModel, isAdded) =>
		{

			if (isAdded)
			{
				commentModel.CreatedDate = ToLocalTime(commentModel.CreatedDate);
				if (_comments == null)
					_comments = new List<CommentsViewModel>();
				_comments.Insert(0, commentModel);
			}
			else
			{
				var existingCommentIndex = _comments.FindIndex(c => c.Id == commentModel.Id);

				if (existingCommentIndex != -1)
				{
					commentModel.UpdatedDate = ToLocalTime(commentModel.UpdatedDate.Value);
					_comments[existingCommentIndex] = commentModel;
				}

			}
			await InvokeAsync(StateHasChanged);
		});

		_commentHubConnection.On<CommentsViewModel, bool>("ReplyAddedOrEditedAsync", async (replyDto, isAdded) =>
		{
			var comment = _comments.FirstOrDefault(c => c.Id == replyDto.ParentCommentId);
			if (comment != null)
			{
				replyDto.CreatedDate = ToLocalTime(replyDto.CreatedDate);
				if (comment.CommentReplies == null)
					_comments.FirstOrDefault(c => c.Id == replyDto.ParentCommentId).CommentReplies = new List<CommentsViewModel>();

				if (isAdded)
					_comments.FirstOrDefault(c => c.Id == replyDto.ParentCommentId)?.CommentReplies.Add(replyDto);
				else
				{
					var existingReplyIndex = comment.CommentReplies.FindIndex(r => r.Id == replyDto.Id);
					if (existingReplyIndex != -1)
					{
						replyDto.UpdatedDate = ToLocalTime(replyDto.UpdatedDate.Value);
						comment.CommentReplies[existingReplyIndex] = replyDto;

					}
				}
			}

			await InvokeAsync(StateHasChanged);
		});

		await _commentHubConnection.StartAsync();
		await _commentHubConnection.SendAsync("JoinPostCommentGroup", postId);
	}
	private async Task StartTasksWithUserRoleAsync()
	{
		if (!_isUserLoggedIn)
		{
			var postTask = PostApi.GetPostByIdAsync(postId);
			var commentsTask = CommentApi.GetPostCommentsAsync(postId);
			var postViewCountTask = PostViewApi.GetPostViewCountAsync(postId);
			var postLikeCountTask = ReactionApi.GetPostLikeCountAsync(postId);
			var postDislikeCountTask = ReactionApi.GetPostDislikeCountAsync(postId);

			await Task.WhenAll(postTask, commentsTask, postViewCountTask, postLikeCountTask, postDislikeCountTask);

			GetPost(postTask.Result);
			GetComments(commentsTask.Result);
			GetPostViewCount(postViewCountTask.Result);
			GetPostLikeCount(postLikeCountTask.Result);
			GetPostDislikeCount(postDislikeCountTask.Result);
		}
		else if (allowedRoles.Contains(_userRoleId))
		{
			var postTask = PostApi.GetPostByIdAsync(postId);
			var commentsTask = CommentApi.GetPostCommentsAsync(postId);
			var postReactionsTask = ReactionApi.GetPostReactionsAsync(postId);
			var viewersTask = PostViewApi.GetPostsViewersAsync(postId);

			await Task.WhenAll(postTask, commentsTask, postReactionsTask, viewersTask);

			GetPost(postTask.Result);
			GetComments(commentsTask.Result);
			GetPostReactions(postReactionsTask.Result);
			GetPostViewers(viewersTask.Result);

		}
		else
		{
			var postTask = PostApi.GetPostByIdAsync(postId);
			var commentsTask = CommentApi.GetPostCommentsAsync(postId);
			var postLikeCountTask = ReactionApi.GetPostLikeCountAsync(postId);
			var postDislikeCountTask = ReactionApi.GetPostDislikeCountAsync(postId);
			var userReactionTask = ReactionApi.GetUserReactionTypeIdAsync(postId, _currentUserId);
			var postViewCountTask = PostViewApi.GetPostViewCountAsync(postId);

			await Task.WhenAll(postTask, commentsTask, postLikeCountTask, postDislikeCountTask, userReactionTask, postViewCountTask);

			GetPost(postTask.Result);
			GetComments(commentsTask.Result);
			GetPostLikeCount(postLikeCountTask.Result);
			GetPostDislikeCount(postDislikeCountTask.Result);
			GetUserReactionTypeId(userReactionTask.Result);
			GetPostViewCount(postViewCountTask.Result);
		}
	}

	private void CheckUserLoggedIn()
	{
		_isUserLoggedIn = AuthStateProvider.IsLoggedIn;
	}
	private void GetUserRoleId()
	{
		if (_isUserLoggedIn)
			_userRoleId = AuthStateProvider.User?.roleId;
		else
			_userRoleId = null;
	}

	private void UserPostOwner()
	{
		if (_postDto == null)
			return;
		if (_userRoleId == null)
			_isPostOwner = false;

		if (Guid.TryParse(AuthStateProvider.User?.id, out Guid parsedId))
		{
			_currentUserId = parsedId;
			_isPostOwner = _postDto.UserId.ToString().Equals(_currentUserId.ToString(), StringComparison.OrdinalIgnoreCase);
		}
		else
			_isPostOwner = false;
	}

	private void NavigateToLogin()
	{
		NavigationManager.NavigateTo("/login");
	}
	private void NavigateToPricing()
	{
		NavigationManager.NavigateTo("/pricing");
	}
	private void NavigateToSendConversation(Guid conversationId)
	{
		NavigationManager.NavigateTo($"/conversations/{conversationId}");
	}
	private async Task LikePostAsync()
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;
		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;
			NavigateToLogin();
			return;
		}
		try
		{
			var result = await ReactionApi.LikePostAsync(postId, _currentUserId.Value);
			if (!result.IsSuccess)
			{
				_isPostHaveError = true;
				_errorMessage = result.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
		_isApiBusy = false;
	}
	private async Task DislikePostAsync()
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;
		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;
			NavigateToLogin();
			return;
		}
		try
		{
			var result = await ReactionApi.DislikePostAsync(postId, _currentUserId.Value);
			if (!result.IsSuccess)
			{
				_isPostHaveError = true;
				_errorMessage = result.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
		_isApiBusy = false;

	}
	private void ReportPost()
	{
		if (!_isUserLoggedIn)
			NavigateToLogin();
	}
	private async Task SendMessageAsync(Guid receiverUserId)
	{

		if (!_isUserLoggedIn)
		{
			NavigateToLogin();
			return;
		}

		if (receiverUserId == _currentUserId)
			return;

		var response = await MessageApi.GetConversationDtoAsync(_currentUserId.Value, receiverUserId);
		_sendMessageErrorModel.Close();
		_sendMessageError = null;
		try
		{
			if (response.IsSuccess)
			{
				_conversationDto = response.Data;
				NavigateToSendConversation(_conversationDto.ConversationId);
			}
			else
			{
				var userRole = AuthStateProvider.User?.roleId;
				if (!allowedRoles.Contains(userRole))
					NavigateToPricing();
				else
				{
					_sendMessageErrorModel.Open();
					_sendMessageError = response.ErrorMessage;
				}

			}
		}
		catch (Exception ex)
		{
			_sendMessageErrorModel.Open();
			_sendMessageError = ex.Message;
		}
	}
	private void ShowLikes()
	{
		if (!allowedRoles.Contains(_userRoleId))
		{
			NavigateToPricing();
			return;
		}

		_likesModel.Open();
	}
	private void ShowDislikes()
	{
		if (!allowedRoles.Contains(_userRoleId))
		{
			NavigateToPricing();
			return;
		}

		_dislikeModel.Open();
	}
	private void ShowComments()
	{
		_showComments = !_showComments;
	}
	private void ShowCommentReplies(CommentsViewModel comment)
	{
		comment.ShowReplies = !comment.ShowReplies;
	}
	private void ToggleReplyBox(int commentId)
	{
		if (_replyToCommentId == commentId)
		{
			_replyToCommentId = null;
			_replyText = string.Empty;
		}
		else
		{
			_replyToCommentId = commentId;
			_replyText = string.Empty;
		}
	}

	private void ShowViwers()
	{
		if (!allowedRoles.Contains(_userRoleId))
		{
			NavigateToPricing();
			return;
		}
		_viewerModel.Open();
	}
	private async Task ReadPostAsync()
	{
		if (!_isUserLoggedIn)
			return;

		var response = await PostViewApi.ReadPostAsync(postId, _currentUserId);
		try
		{
			if (!response.IsSuccess)
			{
				_isPostHaveError = true;
				_errorMessage = response.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void UpdatePostReactionCounts()
	{
		_likeCount = _postReactions?.Count(r => r.ReactionTypeId == (int)ReactionTypeEnum.Like) ?? 0;
		_dislikeCount = _postReactions?.Count(r => r.ReactionTypeId == (int)ReactionTypeEnum.Dislike) ?? 0;
	}
	private void UpdatePostReactionButtons()
	{
		_isAlreadyLiked = _postReactions?.Any(r => r.ReactingUserId == _currentUserId && r.ReactionTypeId == (int)ReactionTypeEnum.Like) ?? false;
		_isAlreadyDisliked = _postReactions?.Any(r => r.ReactingUserId == _currentUserId && r.ReactionTypeId == (int)ReactionTypeEnum.Dislike) ?? false;
	}
	private void UpdatePostReactions(ReactionViewModel reaction, bool? isReactionUpdated)
	{
		reaction.CreatedDate = ToLocalTime(reaction.CreatedDate);

		if (isReactionUpdated == true)
		{
			var index = _postReactions?.FindIndex(r => r.ReactingUserId == reaction.ReactingUserId) ?? -1;
			if (index >= 0 && _postReactions != null)
				_postReactions[index] = reaction;
		}
		else
			_postReactions?.Add(reaction);

		UpdatePostReactionCounts();
		UpdatePostReactionButtons();
	}

	private void UpdatePostReactions(int? oldReactionId, int newReactionId)
	{
		var oldLikeCount = _likeCount;
		var oldDislikeCount = _dislikeCount;

		if (oldReactionId == null || oldReactionId == (int)ReactionTypeEnum.Cancelled)
		{
			if (newReactionId == (int)ReactionTypeEnum.Like)
				_likeCount++;
			else
				_dislikeCount++;
		}
		else if (oldReactionId == (int)ReactionTypeEnum.Like)
		{
			if (newReactionId == (int)ReactionTypeEnum.Dislike)
			{
				_likeCount--;
				_dislikeCount++;
			}
			else
				_likeCount--;
		}
		else if (oldReactionId == (int)ReactionTypeEnum.Dislike)
		{
			if (newReactionId == (int)ReactionTypeEnum.Like)
			{
				_dislikeCount--;
				_likeCount++;
			}
			else
				_dislikeCount--;
		}


		// if (_currentUserId == UserId)
		// {
		// 	if (newReactionId == (int)ReactionTypeEnum.Like)
		// 	{
		// 		_isAlreadyLiked = true;
		// 		_isAlreadyDisliked = false;
		// 	}
		// 	else if (newReactionId == (int)ReactionTypeEnum.Dislike)
		// 	{
		// 		_isAlreadyLiked = false;
		// 		_isAlreadyDisliked = true;
		// 	}
		// 	else
		// 	{
		// 		_isAlreadyLiked = false;
		// 		_isAlreadyDisliked = false;
		// 	}

		// }
	}


	private void UpdateCommentReactions(ReactionViewModel reaction, bool? isReactionUpdated)
	{
		reaction.CreatedDate = ToLocalTime(reaction.CreatedDate);

		var targetComment = _comments.FirstOrDefault(c => c.Id == reaction.CommentId);
		if (targetComment == null)
		{
			foreach (var c in _comments)
			{
				if (c.CommentReplies == null) continue;

				targetComment = c.CommentReplies.FirstOrDefault(r => r.Id == reaction.CommentId);
				if (targetComment != null)
					break;
			}
		}

		if (targetComment == null)
			return;

		if (targetComment.CommentRections == null)
			targetComment.CommentRections = new List<ReactionViewModel>();

		if (isReactionUpdated == true)
		{
			var existingReaction = targetComment.CommentRections
				.FirstOrDefault(r => r.ReactingUserId == reaction.ReactingUserId);

			if (existingReaction.ReactionTypeId == (int)ReactionTypeEnum.Like)
			{
				if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Dislike)
					targetComment.DislikeCount++;

				targetComment.LikeCount--;

			}
			else if (existingReaction.ReactionTypeId == (int)ReactionTypeEnum.Dislike)
			{

				if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Like)
					targetComment.LikeCount++;

				targetComment.DislikeCount--;
			}
			else
			{
				if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Like)
					targetComment.LikeCount++;
				else
					targetComment.DislikeCount++;
			}

			var index = targetComment.CommentRections.IndexOf(existingReaction);
			targetComment.CommentRections[index] = reaction;

		}
		else
		{
			targetComment.CommentRections.Add(reaction);

			if (reaction.ReactionTypeId == (int)ReactionTypeEnum.Like)
				targetComment.LikeCount++;
			else
				targetComment.DislikeCount++;

		}

	}

	private void UpdateCommentReactions(int commentId, int? oldReactionId, int newReactionId)
	{

		var targetComment = _comments.FirstOrDefault(c => c.Id == commentId);
		if (targetComment == null)
		{
			foreach (var c in _comments)
			{
				if (c.CommentReplies == null)
					continue;
				targetComment = c.CommentReplies.FirstOrDefault(cr => cr.Id == commentId);
				if (targetComment != null)
					break;
			}
		}

		if (targetComment == null)
			return;

		var likeCount = targetComment?.LikeCount ?? 0;
		var dislikeCount = targetComment?.DislikeCount ?? 0;

		if (oldReactionId is null)
		{
			if (newReactionId == (int)ReactionTypeEnum.Like)
				likeCount++;
			else
				dislikeCount++;
		}
		else
		{
			if (oldReactionId == (int)ReactionTypeEnum.Cancelled)
			{
				if (newReactionId == (int)ReactionTypeEnum.Like)
					likeCount++;
				else
					dislikeCount++;
			}
			else if (oldReactionId == (int)ReactionTypeEnum.Like)
			{
				if (newReactionId == (int)ReactionTypeEnum.Dislike)
					dislikeCount++;

				likeCount--;
			}
			else if (oldReactionId == (int)ReactionTypeEnum.Dislike)
			{
				if (newReactionId == (int)ReactionTypeEnum.Like)
					likeCount++;

				dislikeCount--;
			}
		}

		targetComment.LikeCount = likeCount;
		targetComment.DislikeCount = dislikeCount;
	}

	private void UpdateCommentReactionCount(int? commentId)
	{
		var comment = _comments.FirstOrDefault(c => c.Id == commentId);
		if (comment != null && comment.CommentRections != null)
		{
			comment.LikeCount = comment.CommentRections.Count(r => r.ReactionTypeId == (int)ReactionTypeEnum.Like);
			comment.DislikeCount = comment.CommentRections.Count(r => r.ReactionTypeId == (int)ReactionTypeEnum.Dislike);
		}
	}


	private string GetUserGenderName(int genderId)
	{
		switch (genderId)
		{
			case (int)GenderEnum.Male:
				return "Erkek";
			case (int)GenderEnum.Female:
				return "Kadın";
			default:
				return "";
		}
	}
	private void GetUserReactionTypeId(ApiResponses<int?> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				if (response.Data == (int)ReactionTypeEnum.Like)
					_isAlreadyLiked = true;
				else if (response.Data == (int)ReactionTypeEnum.Dislike)
					_isAlreadyDisliked = true;
				else
				{
					_isAlreadyLiked = false;
					_isAlreadyDisliked = false;
				}

				if (_errorMessage != null)
					_errorMessage = null;
				_isPostHaveError = false;
			}
			else
			{
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetPost(ApiResponses<PostViewModel> response)
	{
		try
		{
			if (response.IsSuccess)
			{
				_postDto = response.Data;
				if (_postDto.UpdatedDate != null)
					_postDto.UpdatedDate = ToLocalTime(_postDto.UpdatedDate.Value);
				_postDto.CreatedDate = ToLocalTime(_postDto.CreatedDate);
				_errorMessage = null;
				_isPostHaveError = false;
			}
			else
			{
				_postDto = null;
				_isPostHaveError = true;
				_errorMessage = response.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetPostReactions(ApiResponses<List<ReactionViewModel>> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_postReactions = response.Data;

				if (_postReactions?.Count != 0)
				{
					foreach (var reaction in _postReactions)
					{
						reaction.CreatedDate = ToLocalTime(reaction.CreatedDate);
					}
				}

				if (_errorMessage != null)
					_errorMessage = null;
				_isPostHaveError = false;
			}
			else
			{
				_postReactions = null;
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetPostLikeCount(ApiResponses<int> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_likeCount = response.Data;
				if (_errorMessage != null)
					_errorMessage = null;
				_isPostHaveError = false;
			}
			else
			{
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetPostDislikeCount(ApiResponses<int> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_dislikeCount = response.Data;
				_isPostHaveError = false;

				if (_errorMessage != null)
					_errorMessage = null;
			}
			else
			{
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetPostViewCount(ApiResponses<int> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_postViewCount = response.Data;
				_isPostHaveError = false;

				if (_errorMessage != null)
					_errorMessage = null;
			}
			else
			{
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}
	private void GetComments(ApiResponses<List<CommentsViewModel>> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_comments = response.Data
					.OrderByDescending(c => c.CreatedDate)
					.ToList();
				if (_comments.Count != 0)
				{
					foreach (var comment in _comments)
					{
						comment.CreatedDate = ToLocalTime(comment.CreatedDate);
						if (comment.UpdatedDate != null)
							comment.UpdatedDate = ToLocalTime(comment.UpdatedDate.Value);

						if (comment.CommentReplies != null && comment.CommentReplies.Count > 0)
						{
							foreach (var reply in comment.CommentReplies)
							{
								reply.CreatedDate = ToLocalTime(reply.CreatedDate);
								if (reply.UpdatedDate != null)
									reply.UpdatedDate = ToLocalTime(reply.UpdatedDate.Value);
							}
						}
					}
				}

				_commentErrorMessage = null;
			}
			else
			{
				_comments = null;
				_commentErrorMessage = response.ErrorMessage;
			}
			_isCommentsHaveError = false;
		}
		catch (Exception ex)
		{
			_isCommentsHaveError = true;
			_commentErrorMessage = ex.Message;
		}
	}
	private void GetPostViewers(ApiResponses<List<PostViewersViewModel>> response)
	{
		if (_isPostHaveError)
			return;
		try
		{
			if (response.IsSuccess)
			{
				_viewers = response.Data;
				if (_viewers?.Count != 0)
				{
					foreach (var viewer in _viewers)
					{
						viewer.ReadDate = ToLocalTime(viewer.ReadDate);
					}
				}

				_postViewCount = _viewers.Count;
				_errorMessage = null;
				_isPostHaveError = false;
			}
			else
			{
				_viewers = null;
				_errorMessage = response.ErrorMessage;
				_isPostHaveError = true;
			}

		}
		catch (Exception ex)
		{
			_viewers = null;
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
	}

	private void ShowUserProfile()
	{
		NavigationManager.NavigateTo($"/profile/{_postDto.UserId}");
	}
	private void ShowUserProfile(Guid UserId)
	{
		NavigationManager.NavigateTo($"/profile/{UserId}");
	}

	private async Task AddCommentAsync()
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;
		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;

			NavigateToLogin();
			return;
		}
		if (string.IsNullOrWhiteSpace(_commentModel.Content))
		{
			_isApiBusy = false;
			return;
		}

		_newCommentText = _commentModel.Content.Trim();
		if (string.IsNullOrWhiteSpace(_newCommentText))
		{
			_isApiBusy = false;
			return;
		}

		try
		{
			var result = await CommentApi.AddCommentAsync(postId, (Guid)_currentUserId, _commentModel);
			if (!result.IsSuccess)
			{
				_isCommentsHaveError = true;
				_commentErrorMessage = result.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isCommentsHaveError = true;
			_commentErrorMessage = ex.Message;
		}
		_commentModel.Content = string.Empty;
		_isApiBusy = false;

	}

	private async Task AddReplyAsync(int parentCommentId)
	{
		if (_isApiBusy)
			return;

		_isApiBusy = true;

		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;
			NavigateToLogin();
			return;
		}
		if (string.IsNullOrWhiteSpace(_replyModel.Content))
		{
			_isApiBusy = false;
			return;
		}
		var _newReplyText = _replyModel.Content.Trim();
		if (string.IsNullOrWhiteSpace(_newReplyText))
		{
			_isApiBusy = false;
			return;
		}

		try
		{
			var result = await CommentApi.AddReplyCommentAsync(postId, parentCommentId, (Guid)_currentUserId, _replyModel);
			if (!result.IsSuccess)
			{
				_isCommentsHaveError = true;
				_commentErrorMessage = result.ErrorMessage;
			}

			var comment = _comments.FirstOrDefault(c => c.Id == parentCommentId);
			if (comment is not null)
				comment.ShowReplies = true;

		}
		catch (Exception ex)
		{
			_isCommentsHaveError = true;
			_commentErrorMessage = ex.Message;
		}
		_replyModel.Content = string.Empty;
		_replyToCommentId = null;
		_isApiBusy = false;
	}

	private DateTime ToLocalTime(DateTime date)
	{
		return DateTimeHelperService.ToLocal(date, _userTimeZoneId);
	}

	private void NavigateToUserProfile(Guid userId)
	{
		NavigationManager.NavigateTo($"/profile/{userId}");
	}

	private async Task DisplayCommentDeleteWarningAsync(int commentId)
	{
		var comment = _comments.FirstOrDefault(c => c.Id == commentId);

		if (comment.Id == commentId && comment.UserId == _currentUserId || adminRoles.Contains(_userRoleId))
			comment.ShowDeleteWarning = !comment.ShowDeleteWarning;

		await InvokeAsync(StateHasChanged);
	}

	private async Task DisplayReplyDeleteWarningAsync(int commentId, int replyId)
	{
		var replies = _comments.FirstOrDefault(c => c.Id == commentId)?.CommentReplies.ToList();
		var reply = replies.FirstOrDefault(r => r.Id == replyId);

		if (reply.Id == replyId && reply.UserId == _currentUserId || adminRoles.Contains(_userRoleId))
			reply.ShowDeleteWarning = !reply.ShowDeleteWarning;

		await InvokeAsync(StateHasChanged);
	}

	private async Task DisplayCommentEditingAsync(int commentId)
	{
		var comment = _comments.FirstOrDefault(c => c.Id == commentId);

		if (comment.Id == commentId && comment.UserId == _currentUserId || adminRoles.Contains(_userRoleId))
			comment.IsCommentEditing = !comment.IsCommentEditing;

		if (comment.IsCommentEditing)
			_commentContent = comment.Content;
		else
			comment.Content = _commentContent;

		await InvokeAsync(StateHasChanged);
	}

	private async Task DisplayReplyEditingAsync(int commentId, int replyId)
	{
		var replies = _comments.FirstOrDefault(c => c.Id == commentId)?.CommentReplies.ToList();
		var reply = replies.FirstOrDefault(r => r.Id == replyId);

		if (reply.Id == replyId && reply.UserId == _currentUserId || adminRoles.Contains(_userRoleId))
			reply.IsCommentEditing = !reply.IsCommentEditing;

		if (reply.IsCommentEditing)
			_commentContent = reply.Content;
		else
			reply.Content = _commentContent;

		await InvokeAsync(StateHasChanged);

	}


	private async Task DeleteCommentAsync(int commentId)
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;
		bool isReply = false;

		CommentsViewModel model = _comments.FirstOrDefault(c => c.Id == commentId);
		if (model == null)
		{
			isReply = true;
			model = _comments.SelectMany(c => c.CommentReplies).FirstOrDefault(r => r.Id == commentId);
			if (model == null)
			{
				_isApiBusy = false;
				return;
			}
		}

		try
		{
			var response = await CommentApi.DeleteCommentAsync(model, (Guid)_currentUserId);

			if (!response.IsSuccess)
			{
				_isPostHaveError = true;
				_errorMessage = response.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
		finally
		{
			_isApiBusy = false;

			// if (isReply)
			// 	await DisplayReplyDeleteWarningAsync(model.ParentCommentId.Value, model.Id);
			// else
			// 	await DisplayCommentDeleteWarningAsync(model.Id);

			await InvokeAsync(StateHasChanged);
		}
	}

	private async Task EditCommentAsync(int commentId)
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;

		bool isReply = false;

		CommentsViewModel model = _comments.FirstOrDefault(c => c.Id == commentId);
		if (model == null)
		{
			model = _comments.SelectMany(c => c.CommentReplies).FirstOrDefault(r => r.Id == commentId);
			if (model == null)
			{
				isReply = true;
				_isApiBusy = false;
				return;
			}
		}

		try
		{
			var response = await CommentApi.EditCommentAsync(model, (Guid)_currentUserId);

			if (!response.IsSuccess)
			{
				_isPostHaveError = true;
				_errorMessage = response.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isPostHaveError = true;
			_errorMessage = ex.Message;
		}
		finally
		{
			_isApiBusy = false;
			await InvokeAsync(StateHasChanged);
		}

	}

	private async Task LikeCommentAsync(int commentId)
	{

		if (_isApiBusy)
			return;
		_isApiBusy = true;
		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;
			NavigateToLogin();
			return;
		}
		try
		{
			var result = await ReactionApi.LikeCommentAsync(commentId, (Guid)_currentUserId);
			if (!result.IsSuccess)
			{
				_isCommentsHaveError = true;
				_commentErrorMessage = result.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isCommentsHaveError = true;
			_commentErrorMessage = ex.Message;
		}
		finally
		{
			_isApiBusy = false;
			await InvokeAsync(StateHasChanged);

		}
	}

	private async Task DislikeCommentAsync(int commentId)
	{
		if (_isApiBusy)
			return;
		_isApiBusy = true;
		if (!_isUserLoggedIn)
		{
			_isApiBusy = false;
			NavigateToLogin();
			return;
		}
		try
		{
			var result = await ReactionApi.DislikeCommentAsync(commentId, (Guid)_currentUserId);
			if (!result.IsSuccess)
			{
				_isCommentsHaveError = true;
				_commentErrorMessage = result.ErrorMessage;
			}
		}
		catch (Exception ex)
		{
			_isCommentsHaveError = true;
			_commentErrorMessage = ex.Message;
		}
		finally
		{
			_isApiBusy = false;
			await InvokeAsync(StateHasChanged);
		}

	}
}


